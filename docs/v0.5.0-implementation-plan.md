# v0.5.0 Implementation Plan

## Overview

This document provides the detailed implementation plan for v0.5.0 unified architecture, including specific code changes, migration steps, and timeline.

## Phase 1: Core Library Implementation (Week 1-2)

### 1.1 Create Core Package Structure

```bash
# Create core package
mkdir -p packages/core/src/{types,validation,errors,utils,cache,security}
cd packages/core

# Initialize package.json
cat > package.json << 'EOF'
{
  "name": "@opencode/core",
  "version": "0.5.0",
  "description": "Core library for OpenCode Workflow Kit",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "type": "module",
  "scripts": {
    "build": "tsc",
    "test": "vitest",
    "lint": "eslint src/**/*.ts",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "zod": "^3.22.4",
    "chalk": "^5.3.0",
    "semver": "^7.6.2"
  },
  "devDependencies": {
    "@types/node": "^22.4.0",
    "@types/semver": "^7.5.8",
    "typescript": "^5.5.3",
    "vitest": "^2.0.0"
  }
}
EOF
```

### 1.2 Unified Type Definitions

```typescript
// packages/core/src/types/index.ts
import { z } from 'zod';

// Base configuration schema
export const GitHubConfigSchema = z.object({
  token: z.string().optional(),
  apiUrl: z.string().url().default('https://api.github.com'),
  owner: z.string().min(1),
  repo: z.string().min(1)
});

export const CodyConfigSchema = z.object({
  projectId: z.string().optional(),
  apiUrl: z.string().url().default('https://api.cody.ai'),
  webhookSecret: z.string().optional()
});

export const BeadsConfigSchema = z.object({
  projectPath: z.string().optional(),
  configPath: z.string().default('.beads/beads.json'),
  autoSync: z.boolean().default(false),
  syncInterval: z.number().min(60).default(300)
});

export const SyncConfigSchema = z.object({
  defaultDirection: z.enum(['cody-to-beads', 'beads-to-cody', 'bidirectional']).default('bidirectional'),
  conflictResolution: z.enum(['manual', 'cody-wins', 'beads-wins', 'newer-wins', 'prompt']).default('manual'),
  preserveComments: z.boolean().default(true),
  preserveLabels: z.boolean().default(true),
  syncMilestones: z.boolean().default(false),
  excludeLabels: z.array(z.string()).default(['wontfix', 'duplicate']),
  includeLabels: z.array(z.string()).default(['bug', 'feature', 'enhancement'])
});

export const UnifiedConfigSchema = z.object({
  version: z.string().regex(/^\d+\.\d+\.\d+$/),
  github: GitHubConfigSchema,
  cody: CodyConfigSchema,
  beads: BeadsConfigSchema,
  sync: SyncConfigSchema,
  agents: z.record(z.any()).optional(),
  templates: z.record(z.any()).optional()
});

export type UnifiedConfig = z.infer<typeof UnifiedConfigSchema>;
export type GitHubConfig = z.infer<typeof GitHubConfigSchema>;
export type CodyConfig = z.infer<typeof CodyConfigSchema>;
export type BeadsConfig = z.infer<typeof BeadsConfigSchema>;
export type SyncConfig = z.infer<typeof SyncConfigSchema>;

// Sync types
export type SyncDirection = 'cody-to-beads' | 'beads-to-cody' | 'bidirectional';
export type ConflictResolutionStrategy = 'manual' | 'cody-wins' | 'beads-wins' | 'newer-wins' | 'prompt';

export interface SyncOptions {
  direction: SyncDirection;
  dryRun: boolean;
  force: boolean;
  since?: Date;
  batchSize?: number;
  timeout?: number;
}

export interface SyncResult {
  success: boolean;
  issuesSynced: number;
  prsSynced: number;
  conflicts: SyncConflict[];
  errors: string[];
  duration: number;
  timestamp: Date;
  metadata?: Record<string, any>;
}

export interface SyncConflict {
  id: string;
  type: 'data' | 'timestamp' | 'deletion' | 'dependency';
  itemId: string;
  itemType: string;
  message: string;
  codyData?: any;
  beadsData?: any;
  resolution?: ConflictResolutionStrategy;
  severity: 'low' | 'medium' | 'high' | 'critical';
}

// API Client interfaces
export interface APIClient {
  name: string;
  connect(): Promise<void>;
  disconnect(): Promise<void>;
  isConnected(): boolean;
  healthCheck(): Promise<boolean>;
}

export interface GitHubClient extends APIClient {
  getIssues(owner: string, repo: string, options?: { since?: Date }): Promise<GitHubIssue[]>;
  getPullRequests(owner: string, repo: string, options?: { since?: Date }): Promise<GitHubIssue[]>;
  createIssue(owner: string, repo: string, issue: Partial<GitHubIssue>): Promise<GitHubIssue>;
  updateIssue(owner: string, repo: string, issueNumber: number, update: Partial<GitHubIssue>): Promise<GitHubIssue>;
}

export interface BeadsClient extends APIClient {
  getIssues(projectPath: string, options?: { since?: Date }): Promise<BeadsIssue[]>;
  createIssue(projectPath: string, issue: Partial<BeadsIssue>): Promise<BeadsIssue>;
  updateIssue(projectPath: string, issueId: string, update: Partial<BeadsIssue>): Promise<BeadsIssue>;
}

// Issue types
export interface GitHubIssue {
  id: number;
  number: number;
  title: string;
  body: string;
  state: 'open' | 'closed';
  labels: { name: string }[];
  assignees: { login: string }[];
  milestone?: { title: string };
  created_at: string;
  updated_at: string;
  closed_at?: string;
  html_url: string;
  user: { login: string };
  comments: number;
  pull_request?: any;
}

export interface BeadsIssue {
  id: string;
  title: string;
  description: string;
  status: string;
  priority?: string;
  assignee?: string;
  labels?: string[];
  created_at: string;
  updated_at: string;
  metadata?: Record<string, any>;
  comments?: BeadsComment[];
}

export interface BeadsComment {
  id: string;
  content: string;
  author: string;
  created_at: string;
  updated_at: string;
}

// Event system
export interface EventBus {
  emit(event: string, data: any): void;
  on(event: string, handler: (data: any) => void): void;
  off(event: string, handler: (data: any) => void): void;
}

export interface SyncEvent {
  type: 'sync.started' | 'sync.completed' | 'sync.failed' | 'conflict.detected' | 'item.synced';
  timestamp: Date;
  data: any;
}
```

### 1.3 Error Handling System

```typescript
// packages/core/src/errors/index.ts
export class OpenCodeError extends Error {
  constructor(
    public code: string,
    message: string,
    public details?: any,
    public cause?: Error
  ) {
    super(message);
    this.name = 'OpenCodeError';
    
    // Maintains proper stack trace for where our error was thrown
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, OpenCodeError);
    }
  }

  toJSON() {
    return {
      name: this.name,
      code: this.code,
      message: this.message,
      details: this.details,
      cause: this.cause?.message,
      stack: this.stack
    };
  }
}

export const ErrorCodes = {
  // Configuration errors
  CONFIG_INVALID: 'CONFIG_INVALID',
  CONFIG_NOT_FOUND: 'CONFIG_NOT_FOUND',
  CONFIG_SCHEMA_ERROR: 'CONFIG_SCHEMA_ERROR',
  
  // Sync errors
  SYNC_CONFLICT: 'SYNC_CONFLICT',
  SYNC_FAILED: 'SYNC_FAILED',
  SYNC_TIMEOUT: 'SYNC_TIMEOUT',
  
  // API errors
  API_FAILURE: 'API_FAILURE',
  API_TIMEOUT: 'API_TIMEOUT',
  API_RATE_LIMIT: 'API_RATE_LIMIT',
  API_UNAUTHORIZED: 'API_UNAUTHORIZED',
  
  // Agent errors
  AGENT_ERROR: 'AGENT_ERROR',
  AGENT_NOT_FOUND: 'AGENT_NOT_FOUND',
  AGENT_PERMISSION_DENIED: 'AGENT_PERMISSION_DENIED',
  
  // File system errors
  FILE_NOT_FOUND: 'FILE_NOT_FOUND',
  FILE_PERMISSION_DENIED: 'FILE_PERMISSION_DENIED',
  FILE_CORRUPTED: 'FILE_CORRUPTED',
  
  // Network errors
  NETWORK_ERROR: 'NETWORK_ERROR',
  NETWORK_TIMEOUT: 'NETWORK_TIMEOUT',
  
  // Validation errors
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  VALIDATION_FAILED: 'VALIDATION_FAILED'
} as const;

export type ErrorCode = typeof ErrorCodes[keyof typeof ErrorCodes];

// Error factory functions
export const createConfigError = (message: string, details?: any): OpenCodeError => {
  return new OpenCodeError(ErrorCodes.CONFIG_INVALID, message, details);
};

export const createSyncError = (message: string, details?: any): OpenCodeError => {
  return new OpenCodeError(ErrorCodes.SYNC_FAILED, message, details);
};

export const createAPIError = (code: ErrorCode, message: string, details?: any): OpenCodeError => {
  return new OpenCodeError(code, message, details);
};

// Error handler utility
export class ErrorHandler {
  static handle(error: unknown, context?: string): OpenCodeError {
    if (error instanceof OpenCodeError) {
      return error;
    }

    if (error instanceof Error) {
      return new OpenCodeError(
        ErrorCodes.VALIDATION_ERROR,
        `${context ? `${context}: ` : ''}${error.message}`,
        { originalError: error.name },
        error
      );
    }

    return new OpenCodeError(
      ErrorCodes.VALIDATION_ERROR,
      `Unknown error: ${String(error)}`,
      { context }
    );
  }

  static async safeExecute<T>(
    operation: () => Promise<T>,
    context?: string
  ): Promise<{ success: boolean; result?: T; error?: OpenCodeError }> {
    try {
      const result = await operation();
      return { success: true, result };
    } catch (error) {
      return { success: false, error: ErrorHandler.handle(error, context) };
    }
  }
}
```

### 1.4 Validation System

```typescript
// packages/core/src/validation/index.ts
import { z } from 'zod';
import { UnifiedConfig, UnifiedConfigSchema } from '../types/index.js';
import { OpenCodeError, ErrorCodes, createConfigError } from '../errors/index.js';

export interface ValidationResult {
  valid: boolean;
  errors: string[];
  warnings: string[];
}

export class UnifiedValidator {
  private schemas: Map<string, z.ZodSchema> = new Map();

  constructor() {
    this.schemas.set('unified-config', UnifiedConfigSchema);
  }

  validateConfig(config: unknown): ValidationResult {
    const result: ValidationResult = {
      valid: true,
      errors: [],
      warnings: []
    };

    try {
      const schema = this.schemas.get('unified-config');
      if (!schema) {
        throw new Error('Unified config schema not found');
      }

      const validatedConfig = schema.parse(config);
      
      // Additional business logic validation
      this.validateBusinessRules(validatedConfig, result);
      
    } catch (error) {
      if (error instanceof z.ZodError) {
        result.valid = false;
        result.errors = error.errors.map(err => 
          `${err.path.join('.')}: ${err.message}`
        );
      } else {
        result.valid = false;
        result.errors.push([error instanceof Error ? error.message : 'Unknown validation error']);
      }
    }

    return result;
  }

  validateSyncOptions(options: unknown): ValidationResult {
    const result: ValidationResult = {
      valid: true,
      errors: [],
      warnings: []
    };

    const SyncOptionsSchema = z.object({
      direction: z.enum(['cody-to-beads', 'beads-to-cody', 'bidirectional']),
      dryRun: z.boolean(),
      force: z.boolean(),
      since: z.date().optional(),
      batchSize: z.number().min(1).max(1000).optional(),
      timeout: z.number().min(1000).optional()
    });

    try {
      SyncOptionsSchema.parse(options);
    } catch (error) {
      if (error instanceof z.ZodError) {
        result.valid = false;
        result.errors = error.errors.map(err => 
          `${err.path.join('.')}: ${err.message}`
        );
      }
    }

    return result;
  }

  private validateBusinessRules(config: UnifiedConfig, result: ValidationResult): void {
    // At least one project must be configured
    if (!config.cody.projectId && !config.beads.projectPath) {
      result.valid = false;
      result.errors.push('Either Cody project ID or Beads project path must be configured');
    }

    // Validate sync configuration
    if (config.sync.defaultDirection === 'bidirectional') {
      if (!config.cody.projectId || !config.beads.projectPath) {
        result.warnings.push('Bidirectional sync requires both Cody and Beads projects to be configured');
      }
    }

    // Validate GitHub configuration
    if (!config.github.token) {
      result.warnings.push('GitHub token not configured - API rate limits will apply');
    }

    // Validate file paths
    if (config.beads.projectPath && !this.isValidPath(config.beads.projectPath)) {
      result.valid = false;
      result.errors.push('Invalid Beads project path');
    }
  }

  private isValidPath(path: string): boolean {
    // Basic path validation - prevent path traversal
    return !path.includes('..') && !path.startsWith('/') && path.length > 0;
  }

  addSchema(name: string, schema: z.ZodSchema): void {
    this.schemas.set(name, schema);
  }

  getSchema(name: string): z.ZodSchema | undefined {
    return this.schemas.get(name);
  }
}
```

### 1.5 Caching System

```typescript
// packages/core/src/cache/index.ts
export interface CacheEntry<T> {
  value: T;
  timestamp: number;
  ttl: number;
  hits: number;
}

export interface CacheOptions {
  ttl?: number; // Time to live in milliseconds
  maxSize?: number; // Maximum number of entries
  cleanupInterval?: number; // Cleanup interval in milliseconds
}

export class MemoryCache<T = any> {
  private cache = new Map<string, CacheEntry<T>>();
  private cleanupTimer?: NodeJS.Timeout;
  private options: Required<CacheOptions>;

  constructor(options: CacheOptions = {}) {
    this.options = {
      ttl: options.ttl || 300000, // 5 minutes default
      maxSize: options.maxSize || 1000,
      cleanupInterval: options.cleanupInterval || 60000 // 1 minute default
    };

    // Start cleanup timer
    this.startCleanup();
  }

  async get(key: string): Promise<T | null> {
    const entry = this.cache.get(key);
    
    if (!entry) {
      return null;
    }

    // Check if expired
    if (this.isExpired(entry)) {
      this.cache.delete(key);
      return null;
    }

    // Update hit count
    entry.hits++;
    return entry.value;
  }

  async set(key: string, value: T, ttl?: number): Promise<void> {
    // Check size limit
    if (this.cache.size >= this.options.maxSize) {
      this.evictLeastUsed();
    }

    const entry: CacheEntry<T> = {
      value,
      timestamp: Date.now(),
      ttl: ttl || this.options.ttl,
      hits: 0
    };

    this.cache.set(key, entry);
  }

  async delete(key: string): Promise<boolean> {
    return this.cache.delete(key);
  }

  async clear(): Promise<void> {
    this.cache.clear();
  }

  async has(key: string): Promise<boolean> {
    const entry = this.cache.get(key);
    return entry !== undefined && !this.isExpired(entry);
  }

  size(): number {
    return this.cache.size;
  }

  private isExpired(entry: CacheEntry<T>): boolean {
    return Date.now() - entry.timestamp > entry.ttl;
  }

  private evictLeastUsed(): void {
    let leastUsed: string | null = null;
    let minHits = Infinity;

    for (const [key, entry] of this.cache.entries()) {
      if (entry.hits < minHits) {
        minHits = entry.hits;
        leastUsed = key;
      }
    }

    if (leastUsed) {
      this.cache.delete(leastUsed);
    }
  }

  private startCleanup(): void {
    this.cleanupTimer = setInterval(() => {
      this.cleanup();
    }, this.options.cleanupInterval);
  }

  private cleanup(): void {
    const now = Date.now();
    const expiredKeys: string[] = [];

    for (const [key, entry] of this.cache.entries()) {
      if (now - entry.timestamp > entry.ttl) {
        expiredKeys.push(key);
      }
    }

    for (const key of expiredKeys) {
      this.cache.delete(key);
    }
  }

  destroy(): void {
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
    }
    this.cache.clear();
  }
}

// Cache factory for different types
export class CacheFactory {
  private static instances = new Map<string, MemoryCache>();

  static getInstance<T>(name: string, options?: CacheOptions): MemoryCache<T> {
    if (!this.instances.has(name)) {
      this.instances.set(name, new MemoryCache<T>(options));
    }
    return this.instances.get(name) as MemoryCache<T>;
  }

  static destroyAll(): void {
    for (const cache of this.instances.values()) {
      cache.destroy();
    }
    this.instances.clear();
  }
}
```

## Phase 2: CLI Unification (Week 3-4)

### 2.1 Create Unified CLI Package

```bash
# Create unified CLI package
mkdir -p packages/unified-cli/src/{commands,plugins,middleware,utils}
cd packages/unified-cli

# Initialize package.json
cat > package.json << 'EOF'
{
  "name": "@opencode/cli",
  "version": "0.5.0",
  "description": "Unified CLI for OpenCode Workflow Kit",
  "main": "dist/index.js",
  "bin": {
    "opencode": "./bin/opencode.js"
  },
  "type": "module",
  "scripts": {
    "build": "tsc",
    "test": "vitest",
    "dev": "tsc --watch"
  },
  "dependencies": {
    "@opencode/core": "workspace:*",
    "commander": "^12.1.0",
    "chalk": "^5.3.0",
    "inquirer": "^10.0.2",
    "ora": "^8.0.1",
    "dotenv": "^16.4.5"
  },
  "devDependencies": {
    "@types/node": "^22.4.0",
    "@types/inquirer": "^9.0.7",
    "typescript": "^5.5.3",
    "vitest": "^2.0.0"
  }
}
EOF
```

### 2.2 Plugin Architecture

```typescript
// packages/unified-cli/src/plugins/Plugin.ts
import { Command } from 'commander';
import { CLIContext } from '../types/index.js';

export interface CommandDefinition {
  name: string;
  description: string;
  options?: CommandOption[];
  handler: (context: CLIContext) => Promise<void>;
}

export interface CommandOption {
  flags: string;
  description: string;
  defaultValue?: any;
}

export interface Middleware {
  name: string;
  priority: number;
  execute(context: CLIContext, next: () => Promise<void>): Promise<void>;
}

export interface Hook {
  name: string;
  handler: (...args: any[]) => Promise<void> | void;
}

export interface CLIPlugin {
  name: string;
  version: string;
  description: string;
  commands: CommandDefinition[];
  middleware?: Middleware[];
  hooks?: Hook[];
  dependencies?: string[];
}

export interface CLIContext {
  command: string;
  args: any;
  config?: any;
  plugins: Map<string, CLIPlugin>;
  logger: Logger;
  cache: Map<string, any>;
}

export interface Logger {
  debug(message: string, ...args: any[]): void;
  info(message: string, ...args: any[]): void;
  warn(message: string, ...args: any[]): void;
  error(message: string, ...args: any[]): void;
  success(message: string, ...args: any[]): void;
}
```

### 2.3 Core CLI Implementation

```typescript
// packages/unified-cli/src/CLI.ts
import { Command } from 'commander';
import { CLIPlugin, CLIContext, Middleware } from './types/index.js';
import { Logger } from './utils/Logger.js';
import { PluginManager } from './plugins/PluginManager.js';
import { MiddlewareManager } from './middleware/MiddlewareManager.js';
import { ConfigMiddleware } from './middleware/ConfigMiddleware.js';
import { ErrorHandlingMiddleware } from './middleware/ErrorHandlingMiddleware.js';
import { LoggingMiddleware } from './middleware/LoggingMiddleware.js';

export class CLI {
  private program: Command;
  private pluginManager: PluginManager;
  private middlewareManager: MiddlewareManager;
  private logger: Logger;

  constructor() {
    this.program = new Command();
    this.logger = new Logger();
    this.pluginManager = new PluginManager();
    this.middlewareManager = new MiddlewareManager();
    
    this.setup();
  }

  private setup(): void {
    // Configure program
    this.program
      .name('opencode')
      .description('Unified CLI for OpenCode Workflow Kit')
      .version('0.5.0');

    // Add global options
    this.program
      .option('--verbose', 'Enable verbose logging')
      .option('--config <path>', 'Path to configuration file')
      .option('--dry-run', 'Show what would be done without executing');

    // Register core middleware
    this.middlewareManager.register(new LoggingMiddleware(this.logger), 100);
    this.middlewareManager.register(new ConfigMiddleware(), 200);
    this.middlewareManager.register(new ErrorHandlingMiddleware(this.logger), 300);
  }

  async loadPlugin(plugin: CLIPlugin): Promise<void> {
    await this.pluginManager.load(plugin);
    
    // Register plugin middleware
    if (plugin.middleware) {
      for (const middleware of plugin.middleware) {
        this.middlewareManager.register(middleware);
      }
    }

    // Register plugin commands
    for (const commandDef of plugin.commands) {
      this.registerCommand(commandDef);
    }
  }

  private registerCommand(commandDef: CommandDefinition): void {
    const command = this.program
      .command(commandDef.name)
      .description(commandDef.description);

    // Add command options
    if (commandDef.options) {
      for (const option of commandDef.options) {
        command.option(option.flags, option.description, option.defaultValue);
      }
    }

    // Set command handler
    command.action(async (args) => {
      const context: CLIContext = {
        command: commandDef.name,
        args,
        plugins: this.pluginManager.getPlugins(),
        logger: this.logger,
        cache: new Map()
      };

      await this.middlewareManager.execute(context, async () => {
        await commandDef.handler(context);
      });
    });
  }

  async execute(argv: string[]): Promise<void> {
    try {
      await this.program.parseAsync(argv);
    } catch (error) {
      this.logger.error('CLI execution failed:', error);
      process.exit(1);
    }
  }

  getProgram(): Command {
    return this.program;
  }
}
```

### 2.4 Cody-Beads Integration Plugin

```typescript
// packages/unified-cli/src/plugins/CodyBeadsPlugin.ts
import { CLIPlugin, CommandDefinition, CLIContext } from '../types/index.js';
import { SyncEngine } from '@opencode/core';
import { ConfigManager } from '../config/ConfigManager.js';
import { Logger } from '../utils/Logger.js';

export class CodyBeadsPlugin implements CLIPlugin {
  name = 'cody-beads-integration';
  version = '0.5.0';
  description = 'Cody and Beads integration plugin';

  private configManager: ConfigManager;
  private logger: Logger;

  constructor() {
    this.configManager = new ConfigManager();
    this.logger = new Logger();
  }

  get commands(): CommandDefinition[] {
    return [
      {
        name: 'sync',
        description: 'Synchronize issues and PRs between Cody and Beads',
        options: [
          { flags: '-d, --direction <type>', description: 'Sync direction', defaultValue: 'bidirectional' },
          { flags: '-n, --dry-run', description: 'Show what would be synced without executing' },
          { flags: '-f, --force', description: 'Force sync even if conflicts detected' },
          { flags: '--since <date>', description: 'Sync items since this date (ISO 8601 format)' }
        ],
        handler: this.handleSync.bind(this)
      },
      {
        name: 'config',
        description: 'Manage configuration',
        options: [
          { flags: '--validate', description: 'Validate configuration' },
          { flags: '--show', description: 'Show current configuration' },
          { flags: '--set <key=value>', description: 'Set configuration option' }
        ],
        handler: this.handleConfig.bind(this)
      },
      {
        name: 'init',
        description: 'Initialize project',
        options: [
          { flags: '--template <name>', description: 'Project template', defaultValue: 'minimal' },
          { flags: '--force', description: 'Force initialization' }
        ],
        handler: this.handleInit.bind(this)
      }
    ];
  }

  private async handleSync(context: CLIContext): Promise<void> {
    const { args } = context;
    
    try {
      // Load configuration
      const config = await this.configManager.loadConfig(args.config);
      
      // Create sync engine
      const syncEngine = new SyncEngine(config);
      
      // Execute sync
      const result = await syncEngine.executeSync({
        direction: args.direction,
        dryRun: args.dryRun,
        force: args.force,
        since: args.since ? new Date(args.since) : undefined
      });

      // Display results
      this.displaySyncResults(result);
      
    } catch (error) {
      context.logger.error('Sync failed:', error);
      throw error;
    }
  }

  private async handleConfig(context: CLIContext): Promise<void> {
    const { args } = context;

    if (args.validate) {
      const config = await this.configManager.loadConfig(args.config);
      const validation = this.configManager.validateConfig(config);
      
      if (validation.valid) {
        context.logger.success('Configuration is valid');
      } else {
        context.logger.error('Configuration validation failed:');
        validation.errors.forEach(error => context.logger.error(`  - ${error}`));
      }
    } else if (args.show) {
      const config = await this.configManager.loadConfig(args.config);
      console.log(JSON.stringify(config, null, 2));
    } else if (args.set) {
      const [key, value] = args.set.split('=');
      await this.configManager.setOption(key, value);
      context.logger.success(`Configuration updated: ${key} = ${value}`);
    }
  }

  private async handleInit(context: CLIContext): Promise<void> {
    const { args } = context;
    
    context.logger.info(`Initializing project with template: ${args.template}`);
    
    // Implementation for project initialization
    // This would create configuration files, setup directories, etc.
    
    context.logger.success('Project initialized successfully');
  }

  private displaySyncResults(result: any): void {
    if (result.success) {
      this.logger.success('Sync completed successfully');
      this.logger.info(`Issues synced: ${result.issuesSynced}`);
      this.logger.info(`PRs synced: ${result.prsSynced}`);
      
      if (result.conflicts.length > 0) {
        this.logger.warn(`Conflicts found: ${result.conflicts.length}`);
        result.conflicts.forEach((conflict: any) => {
          this.logger.warn(`  - ${conflict.itemId}: ${conflict.message}`);
        });
      }
    } else {
      this.logger.error('Sync failed');
      result.errors.forEach((error: string) => {
        this.logger.error(`  - ${error}`);
      });
    }
  }
}
```

## Phase 3: Enhanced Sync Engine (Week 5-6)

### 3.1 Refactored Sync Engine

```typescript
// packages/cody-beads-integration/src/sync/SyncEngine.ts
import {
  UnifiedConfig,
  SyncOptions,
  SyncResult,
  SyncConflict,
  SyncEvent,
  EventBus,
  APIClient,
  GitHubClient,
  BeadsClient,
  ErrorHandler,
  OpenCodeError,
  ErrorCodes
} from '@opencode/core';

import { ConflictResolver } from './ConflictResolver.js';
import { SyncPattern } from './patterns/SyncPattern.js';
import { BidirectionalPattern } from './patterns/BidirectionalPattern.js';
import { CodyToBeadsPattern } from './patterns/CodyToBeadsPattern.js';
import { BeadsToCodyPattern } from './patterns/BeadsToCodyPattern.js';
import { BatchProcessor } from './BatchProcessor.js';
import { EventBusImpl } from './EventBusImpl.js';

export class SyncEngine {
  private config: UnifiedConfig;
  private clients: Map<string, APIClient>;
  private conflictResolver: ConflictResolver;
  private eventBus: EventBus;
  private batchProcessor: BatchProcessor;
  private patterns: Map<string, SyncPattern>;

  constructor(config: UnifiedConfig) {
    this.config = config;
    this.clients = new Map();
    this.eventBus = new EventBusImpl();
    this.conflictResolver = new ConflictResolver(config.sync.conflictResolution);
    this.batchProcessor = new BatchProcessor();
    
    this.initializePatterns();
    this.initializeClients();
  }

  private initializePatterns(): void {
    this.patterns = new Map([
      ['bidirectional', new BidirectionalPattern(this.clients, this.eventBus)],
      ['cody-to-beads', new CodyToBeadsPattern(this.clients, this.eventBus)],
      ['beads-to-cody', new BeadsToCodyPattern(this.clients, this.eventBus)]
    ]);
  }

  private async initializeClients(): Promise<void> {
    // Initialize GitHub client
    if (this.config.github.token) {
      const { GitHubClientImpl } = await import('../clients/GitHubClient.js');
      const githubClient = new GitHubClientImpl(this.config.github);
      await githubClient.connect();
      this.clients.set('github', githubClient);
    }

    // Initialize Beads client
    if (this.config.beads.projectPath) {
      const { BeadsClientImpl } = await import('../clients/BeadsClient.js');
      const beadsClient = new BeadsClientImpl(this.config.beads);
      await beadsClient.connect();
      this.clients.set('beads', beadsClient);
    }
  }

  async executeSync(options: SyncOptions): Promise<SyncResult> {
    const startTime = Date.now();
    
    try {
      this.eventBus.emit('sync.started', { options, timestamp: new Date() });

      // Validate options
      this.validateSyncOptions(options);

      // Get sync pattern
      const pattern = this.patterns.get(options.direction);
      if (!pattern) {
        throw new OpenCodeError(
          ErrorCodes.SYNC_FAILED,
          `Unknown sync direction: ${options.direction}`
        );
      }

      // Create sync context
      const context = await this.createSyncContext(options);

      // Execute sync pattern
      const result = await pattern.execute(context);

      // Add timing information
      result.duration = Date.now() - startTime;
      result.timestamp = new Date();

      this.eventBus.emit('sync.completed', { result, timestamp: new Date() });

      return result;

    } catch (error) {
      const syncError = ErrorHandler.handle(error, 'SyncEngine.executeSync');
      
      this.eventBus.emit('sync.failed', { 
        error: syncError, 
        timestamp: new Date() 
      });

      return {
        success: false,
        issuesSynced: 0,
        prsSynced: 0,
        conflicts: [],
        errors: [syncError.message],
        duration: Date.now() - startTime,
        timestamp: new Date()
      };
    }
  }

  private validateSyncOptions(options: SyncOptions): void {
    if (!options.direction) {
      throw new OpenCodeError(
        ErrorCodes.VALIDATION_ERROR,
        'Sync direction is required'
      );
    }

    if (options.since && !(options.since instanceof Date)) {
      throw new OpenCodeError(
        ErrorCodes.VALIDATION_ERROR,
        'Since option must be a valid Date'
      );
    }

    if (options.batchSize && (options.batchSize < 1 || options.batchSize > 1000)) {
      throw new OpenCodeError(
        ErrorCodes.VALIDATION_ERROR,
        'Batch size must be between 1 and 1000'
      );
    }
  }

  private async createSyncContext(options: SyncOptions): Promise<SyncContext> {
    return {
      config: this.config,
      options,
      clients: this.clients,
      eventBus: this.eventBus,
      conflictResolver: this.conflictResolver,
      batchProcessor: this.batchProcessor
    };
  }

  async destroy(): Promise<void> {
    // Disconnect all clients
    for (const client of this.clients.values()) {
      await client.disconnect();
    }
    this.clients.clear();
  }
}

export interface SyncContext {
  config: UnifiedConfig;
  options: SyncOptions;
  clients: Map<string, APIClient>;
  eventBus: EventBus;
  conflictResolver: ConflictResolver;
  batchProcessor: BatchProcessor;
}
```

### 3.2 Advanced Conflict Resolution

```typescript
// packages/cody-beads-integration/src/sync/ConflictResolver.ts
import {
  SyncConflict,
  ConflictResolutionStrategy,
  UnifiedConfig,
  ErrorHandler,
  OpenCodeError,
  ErrorCodes
} from '@opencode/core';

import { DataConflictStrategy } from './strategies/DataConflictStrategy.js';
import { TimestampConflictStrategy } from './strategies/TimestampConflictStrategy.js';
import { DeletionConflictStrategy } from './strategies/DeletionConflictStrategy.js';
import { DependencyConflictStrategy } from './strategies/DependencyConflictStrategy.js';

export interface ResolutionStrategy {
  resolve(conflict: SyncConflict, context: SyncContext): Promise<Resolution>;
}

export interface Resolution {
  action: 'merge' | 'override' | 'skip' | 'manual';
  data?: any;
  message?: string;
}

export class ConflictResolver {
  private strategies: Map<string, ResolutionStrategy>;
  private defaultStrategy: ConflictResolutionStrategy;

  constructor(defaultStrategy: ConflictResolutionStrategy) {
    this.defaultStrategy = defaultStrategy;
    this.strategies = new Map([
      ['data', new DataConflictStrategy()],
      ['timestamp', new TimestampConflictStrategy()],
      ['deletion', new DeletionConflictStrategy()],
      ['dependency', new DependencyConflictStrategy()]
    ]);
  }

  async resolve(conflict: SyncConflict, context: SyncContext): Promise<Resolution> {
    const strategy = this.strategies.get(conflict.type);
    
    if (!strategy) {
      throw new OpenCodeError(
        ErrorCodes.SYNC_CONFLICT,
        `No resolution strategy for conflict type: ${conflict.type}`
      );
    }

    try {
      const resolution = await strategy.resolve(conflict, context);
      
      // Log resolution
      context.eventBus.emit('conflict.resolved', {
        conflict,
        resolution,
        timestamp: new Date()
      });

      return resolution;

    } catch (error) {
      const resolutionError = ErrorHandler.handle(error, 'ConflictResolver.resolve');
      
      // Fall back to default strategy
      if (this.defaultStrategy === 'manual') {
        return {
          action: 'manual',
          message: `Manual resolution required: ${resolutionError.message}`
        };
      }

      return this.applyDefaultStrategy(conflict, resolutionError.message);
    }
  }

  private applyDefaultStrategy(conflict: SyncConflict, errorMessage: string): Resolution {
    switch (this.defaultStrategy) {
      case 'cody-wins':
        return {
          action: 'override',
          data: conflict.codyData,
          message: `Using Cody data (fallback): ${errorMessage}`
        };

      case 'beads-wins':
        return {
          action: 'override',
          data: conflict.beadsData,
          message: `Using Beads data (fallback): ${errorMessage}`
        };

      case 'newer-wins':
        const codyTime = new Date(conflict.codyData?.updated_at || 0);
        const beadsTime = new Date(conflict.beadsData?.updated_at || 0);
        const newerData = codyTime > beadsTime ? conflict.codyData : conflict.beadsData;
        const source = codyTime > beadsTime ? 'Cody' : 'Beads';
        
        return {
          action: 'override',
          data: newerData,
          message: `Using newer ${source} data (fallback): ${errorMessage}`
        };

      default:
        return {
          action: 'manual',
          message: `Manual resolution required: ${errorMessage}`
        };
    }
  }

  addStrategy(type: string, strategy: ResolutionStrategy): void {
    this.strategies.set(type, strategy);
  }

  removeStrategy(type: string): void {
    this.strategies.delete(type);
  }
}
```

## Phase 4: Configuration Integration (Week 7-8)

### 4.1 Unified Configuration Manager

```typescript
// packages/opencode-config/src/config/UnifiedConfigManager.ts
import {
  UnifiedConfig,
  UnifiedConfigSchema,
  ValidationResult,
  ErrorHandler,
  OpenCodeError,
  ErrorCodes
} from '@opencode/core';

import { ConfigLoader } from './loaders/ConfigLoader.js';
import { JSONConfigLoader } from './loaders/JSONConfigLoader.js';
import { YAMLConfigLoader } from './loaders/YAMLConfigLoader.js';
import { EnvConfigLoader } from './loaders/EnvConfigLoader.js';
import { ConfigMerger } from './ConfigMerger.js';
import { ConfigValidator } from './ConfigValidator.js';

export interface ConfigSource {
  type: 'file' | 'env' | 'cli' | 'default';
  priority: number;
  data: any;
  source?: string;
}

export class UnifiedConfigManager {
  private loaders: Map<string, ConfigLoader>;
  private validator: ConfigValidator;
  private merger: ConfigMerger;

  constructor() {
    this.loaders = new Map([
      ['json', new JSONConfigLoader()],
      ['yaml', new YAMLConfigLoader()],
      ['yml', new YAMLConfigLoader()],
      ['env', new EnvConfigLoader()]
    ]);
    
    this.validator = new ConfigValidator();
    this.merger = new ConfigMerger();
  }

  async loadConfig(configPath?: string): Promise<UnifiedConfig> {
    try {
      // 1. Discover configuration sources
      const sources = await this.discoverConfigSources(configPath);
      
      // 2. Sort by priority (highest first)
      sources.sort((a, b) => b.priority - a.priority);
      
      // 3. Load configurations
      const configs = await this.loadConfigurations(sources);
      
      // 4. Merge configurations
      const merged = this.merger.merge(configs);
      
      // 5. Validate merged configuration
      const validation = this.validator.validateConfig(merged);
      
      if (!validation.valid) {
        throw new OpenCodeError(
          ErrorCodes.CONFIG_INVALID,
          'Configuration validation failed',
          { errors: validation.errors, warnings: validation.warnings }
        );
      }

      // 6. Apply schema validation
      const validatedConfig = UnifiedConfigSchema.parse(merged);
      
      return validatedConfig;

    } catch (error) {
      throw ErrorHandler.handle(error, 'UnifiedConfigManager.loadConfig');
    }
  }

  async saveConfig(config: Partial<UnifiedConfig>, configPath?: string): Promise<void> {
    try {
      const fullPath = configPath || this.getDefaultConfigPath();
      const loader = this.getLoaderForPath(fullPath);
      
      // Load existing config if it exists
      const existingConfig = await this.loadExistingConfig(fullPath);
      
      // Merge with new config
      const mergedConfig = { ...existingConfig, ...config };
      
      // Validate before saving
      const validation = this.validator.validateConfig(mergedConfig);
      if (!validation.valid) {
        throw new OpenCodeError(
          ErrorCodes.CONFIG_INVALID,
          'Cannot save invalid configuration',
          { errors: validation.errors }
        );
      }

      // Save configuration
      await loader.save(fullPath, mergedConfig);
      
    } catch (error) {
      throw ErrorHandler.handle(error, 'UnifiedConfigManager.saveConfig');
    }
  }

  async validateConfig(config: any): Promise<ValidationResult> {
    return this.validator.validateConfig(config);
  }

  async getOption(path: string, configPath?: string): Promise<any> {
    const config = await this.loadConfig(configPath);
    return this.getNestedValue(config, path);
  }

  async setOption(path: string, value: any, configPath?: string): Promise<void> {
    const config = await this.loadConfig(configPath);
    this.setNestedValue(config, path, value);
    await this.saveConfig(config, configPath);
  }

  private async discoverConfigSources(configPath?: string): Promise<ConfigSource[]> {
    const sources: ConfigSource[] = [];

    // 1. Default configuration (lowest priority)
    sources.push({
      type: 'default',
      priority: 1,
      data: this.getDefaultConfig()
    });

    // 2. Global configuration
    const globalConfigPath = this.getGlobalConfigPath();
    if (await this.fileExists(globalConfigPath)) {
      sources.push({
        type: 'file',
        priority: 2,
        data: await this.loadFileConfig(globalConfigPath),
        source: globalConfigPath
      });
    }

    // 3. Workspace configuration
    const workspaceConfigPath = this.getWorkspaceConfigPath();
    if (await this.fileExists(workspaceConfigPath)) {
      sources.push({
        type: 'file',
        priority: 3,
        data: await this.loadFileConfig(workspaceConfigPath),
        source: workspaceConfigPath
      });
    }

    // 4. Project configuration
    const projectConfigPath = configPath || this.getProjectConfigPath();
    if (await this.fileExists(projectConfigPath)) {
      sources.push({
        type: 'file',
        priority: 4,
        data: await this.loadFileConfig(projectConfigPath),
        source: projectConfigPath
      });
    }

    // 5. Environment variables
    const envConfig = await this.loadEnvConfig();
    if (Object.keys(envConfig).length > 0) {
      sources.push({
        type: 'env',
        priority: 5,
        data: envConfig
      });
    }

    // 6. Command line arguments (highest priority)
    const cliConfig = this.loadCliConfig();
    if (Object.keys(cliConfig).length > 0) {
      sources.push({
        type: 'cli',
        priority: 6,
        data: cliConfig
      });
    }

    return sources;
  }

  private async loadConfigurations(sources: ConfigSource[]): Promise<any[]> {
    const configs: any[] = [];

    for (const source of sources) {
      try {
        if (source.type === 'file') {
          // Already loaded in discovery
          configs.push(source.data);
        } else if (source.type === 'env') {
          configs.push(source.data);
        } else if (source.type === 'cli') {
          configs.push(source.data);
        } else {
          configs.push(source.data);
        }
      } catch (error) {
        console.warn(`Failed to load config from ${source.type}:`, error);
      }
    }

    return configs;
  }

  private getLoaderForPath(path: string): ConfigLoader {
    const ext = path.split('.').pop()?.toLowerCase();
    if (!ext || !this.loaders.has(ext)) {
      throw new OpenCodeError(
        ErrorCodes.CONFIG_INVALID,
        `Unsupported configuration file format: ${ext}`
      );
    }
    return this.loaders.get(ext)!;
  }

  private async loadFileConfig(path: string): Promise<any> {
    const loader = this.getLoaderForPath(path);
    return loader.load(path);
  }

  private async loadEnvConfig(): Promise<any> {
    const loader = this.loaders.get('env')!;
    return loader.load(process.env);
  }

  private loadCliConfig(): any {
    // Parse command line arguments
    const args = process.argv.slice(2);
    const config: any = {};

    for (let i = 0; i < args.length; i++) {
      const arg = args[i];
      if (arg.startsWith('--')) {
        const key = arg.slice(2);
        const nextArg = args[i + 1];
        
        if (nextArg && !nextArg.startsWith('--')) {
          config[key] = nextArg;
          i++; // Skip next argument as it's a value
        } else {
          config[key] = true;
        }
      }
    }

    return config;
  }

  private getNestedValue(obj: any, path: string): any {
    return path.split('.').reduce((current, key) => current?.[key], obj);
  }

  private setNestedValue(obj: any, path: string, value: any): void {
    const keys = path.split('.');
    const lastKey = keys.pop()!;
    const target = keys.reduce((current, key) => {
      if (!current[key] || typeof current[key] !== 'object') {
        current[key] = {};
      }
      return current[key];
    }, obj);
    target[lastKey] = value;
  }

  private getDefaultConfig(): UnifiedConfig {
    return {
      version: '0.5.0',
      github: {
        owner: '',
        repo: '',
        apiUrl: 'https://api.github.com'
      },
      cody: {
        apiUrl: 'https://api.cody.ai'
      },
      beads: {
        projectPath: './.beads',
        configPath: '.beads/beads.json',
        autoSync: false,
        syncInterval: 300
      },
      sync: {
        defaultDirection: 'bidirectional',
        conflictResolution: 'manual',
        preserveComments: true,
        preserveLabels: true,
        syncMilestones: false,
        excludeLabels: ['wontfix', 'duplicate'],
        includeLabels: ['bug', 'feature', 'enhancement']
      }
    };
  }

  private getDefaultConfigPath(): string {
    return './opencode.config.json';
  }

  private getGlobalConfigPath(): string {
    const home = process.env.HOME || process.env.USERPROFILE || '~';
    return `${home}/.opencode/config.json`;
  }

  private getWorkspaceConfigPath(): string {
    return './workspace.json';
  }

  private getProjectConfigPath(): string {
    return './.opencode/config.json';
  }

  private async fileExists(path: string): Promise<boolean> {
    try {
      await import('fs').then(fs => fs.promises.access(path));
      return true;
    } catch {
      return false;
    }
  }

  private async loadExistingConfig(path: string): Promise<any> {
    try {
      return await this.loadFileConfig(path);
    } catch {
      return {};
    }
  }
}
```

## Phase 5: Testing & Documentation (Week 9-10)

### 5.1 Integration Test Suite

```typescript
// tests/integration/unified-workflow.test.ts
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { TestEnvironment } from './utils/TestEnvironment.js';
import { UnifiedCLI } from '../packages/unified-cli/src/CLI.js';
import { UnifiedConfigManager } from '../packages/opencode-config/src/config/UnifiedConfigManager.js';

describe('Unified Workflow Integration', () => {
  let env: TestEnvironment;
  let cli: UnifiedCLI;
  let configManager: UnifiedConfigManager;

  beforeAll(async () => {
    env = new TestEnvironment();
    await env.setup();
    
    cli = new UnifiedCLI();
    configManager = new UnifiedConfigManager();
  });

  afterAll(async () => {
    await env.teardown();
  });

  describe('Configuration Management', () => {
    it('should load and validate configuration', async () => {
      const config = await configManager.loadConfig();
      
      expect(config).toBeDefined();
      expect(config.version).toMatch(/^\d+\.\d+\.\d+$/);
      expect(config.github).toBeDefined();
      expect(config.cody).toBeDefined();
      expect(config.beads).toBeDefined();
      expect(config.sync).toBeDefined();
    });

    it('should merge configuration from multiple sources', async () => {
      // Set environment variable
      process.env.GITHUB_OWNER = 'test-owner';
      
      const config = await configManager.loadConfig();
      expect(config.github.owner).toBe('test-owner');
      
      // Cleanup
      delete process.env.GITHUB_OWNER;
    });

    it('should validate configuration and report errors', async () => {
      const invalidConfig = {
        version: 'invalid',
        github: {
          owner: '',
          repo: ''
        }
      };

      const validation = await configManager.validateConfig(invalidConfig);
      expect(validation.valid).toBe(false);
      expect(validation.errors.length).toBeGreaterThan(0);
    });
  });

  describe('CLI Commands', () => {
    it('should handle init command', async () => {
      const result = await cli.execute(['init', '--template', 'minimal', '--dry-run']);
      expect(result).toBeDefined();
    });

    it('should handle config command', async () => {
      const result = await cli.execute(['config', '--show']);
      expect(result).toBeDefined();
    });

    it('should handle sync command in dry-run mode', async () => {
      const result = await cli.execute(['sync', '--dry-run', '--direction', 'cody-to-beads']);
      expect(result).toBeDefined();
    });
  });

  describe('Sync Workflows', () => {
    it('should perform bidirectional sync', async () => {
      // Setup test data
      await env.createTestData({
        githubIssues: 10,
        beadsIssues: 5,
        conflicts: 2
      });

      const config = await configManager.loadConfig();
      const { SyncEngine } = await import('../packages/cody-beads-integration/src/sync/SyncEngine.js');
      
      const syncEngine = new SyncEngine(config);
      const result = await syncEngine.executeSync({
        direction: 'bidirectional',
        dryRun: true,
        force: false
      });

      expect(result.success).toBe(true);
      expect(result.issuesSynced).toBeGreaterThan(0);
      expect(result.conflicts.length).toBe(2);
    });

    it('should handle sync conflicts', async () => {
      // Create conflict scenario
      await env.createConflictScenario();

      const config = await configManager.loadConfig();
      const { SyncEngine } = await import('../packages/cody-beads-integration/src/sync/SyncEngine.js');
      
      const syncEngine = new SyncEngine(config);
      const result = await syncEngine.executeSync({
        direction: 'bidirectional',
        dryRun: false,
        force: false
      });

      expect(result.conflicts.length).toBeGreaterThan(0);
      // Verify conflict resolution strategy was applied
    });
  });

  describe('Error Handling', () => {
    it('should handle API failures gracefully', async () => {
      // Simulate API failure
      env.simulateAPIFailure('github');

      const config = await configManager.loadConfig();
      const { SyncEngine } = await import('../packages/cody-beads-integration/src/sync/SyncEngine.js');
      
      const syncEngine = new SyncEngine(config);
      const result = await syncEngine.executeSync({
        direction: 'cody-to-beads',
        dryRun: false,
        force: false
      });

      expect(result.success).toBe(false);
      expect(result.errors.length).toBeGreaterThan(0);
    });

    it('should handle configuration errors', async () => {
      // Create invalid configuration
      await configManager.saveConfig({
        github: { owner: '', repo: '' }
      });

      const cli = new UnifiedCLI();
      
      await expect(
        cli.execute(['sync', '--dry-run'])
      ).rejects.toThrow();
    });
  });

  describe('Performance', () => {
    it('should handle large datasets efficiently', async () => {
      // Create large dataset
      await env.createTestData({
        githubIssues: 10000,
        beadsIssues: 8000
      });

      const startTime = Date.now();
      
      const config = await configManager.loadConfig();
      const { SyncEngine } = await import('../packages/cody-beads-integration/src/sync/SyncEngine.js');
      
      const syncEngine = new SyncEngine(config);
      const result = await syncEngine.executeSync({
        direction: 'bidirectional',
        dryRun: true,
        force: false,
        batchSize: 100
      });

      const duration = Date.now() - startTime;
      
      expect(result.success).toBe(true);
      expect(duration).toBeLessThan(30000); // 30 seconds max
    });
  });
});
```

### 5.2 Performance Benchmarks

```typescript
// tests/performance/benchmarks.test.ts
import { describe, it, expect } from 'vitest';
import { performance } from 'perf_hooks';

describe('Performance Benchmarks', () => {
  it('configuration loading performance', async () => {
    const iterations = 1000;
    const configManager = new UnifiedConfigManager();
    
    const startTime = performance.now();
    
    for (let i = 0; i < iterations; i++) {
      await configManager.loadConfig();
    }
    
    const endTime = performance.now();
    const avgTime = (endTime - startTime) / iterations;
    
    // Should load configuration in under 10ms on average
    expect(avgTime).toBeLessThan(10);
  });

  it('sync engine performance', async () => {
    const datasetSizes = [100, 1000, 5000, 10000];
    const configManager = new UnifiedConfigManager();
    const config = await configManager.loadConfig();
    
    for (const size of datasetSizes) {
      const startTime = performance.now();
      
      // Create test dataset
      const testData = createTestDataset(size);
      
      const { SyncEngine } = await import('../../packages/cody-beads-integration/src/sync/SyncEngine.js');
      const syncEngine = new SyncEngine(config);
      
      const result = await syncEngine.executeSync({
        direction: 'bidirectional',
        dryRun: true,
        force: false
      });
      
      const endTime = performance.now();
      const duration = endTime - startTime;
      
      expect(result.success).toBe(true);
      
      // Performance should scale reasonably
      const expectedMaxTime = size * 0.5; // 0.5ms per item max
      expect(duration).toBeLessThan(expectedMaxTime);
      
      console.log(`Dataset size: ${size}, Duration: ${duration.toFixed(2)}ms`);
    }
  });

  it('memory usage', async () => {
    const initialMemory = process.memoryUsage().heapUsed;
    
    // Perform intensive operations
    const configManager = new UnifiedConfigManager();
    const config = await configManager.loadConfig();
    
    const { SyncEngine } = await import('../../packages/cody-beads-integration/src/sync/SyncEngine.js');
    
    for (let i = 0; i < 100; i++) {
      const syncEngine = new SyncEngine(config);
      await syncEngine.executeSync({
        direction: 'bidirectional',
        dryRun: true,
        force: false
      });
      await syncEngine.destroy();
    }
    
    // Force garbage collection if available
    if (global.gc) {
      global.gc();
    }
    
    const finalMemory = process.memoryUsage().heapUsed;
    const memoryIncrease = finalMemory - initialMemory;
    
    // Memory increase should be reasonable (less than 50MB)
    expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024);
  });
});

function createTestDataset(size: number): any {
  return {
    githubIssues: Array.from({ length: size }, (_, i) => ({
      id: i + 1,
      number: i + 1,
      title: `Issue ${i + 1}`,
      body: `Description for issue ${i + 1}`,
      state: 'open',
      labels: [],
      assignees: [],
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      html_url: `https://github.com/test/repo/issues/${i + 1}`,
      user: { login: 'testuser' },
      comments: 0
    })),
    beadsIssues: Array.from({ length: size / 2 }, (_, i) => ({
      id: `beads-${i + 1}`,
      title: `Beads Issue ${i + 1}`,
      description: `Description for beads issue ${i + 1}`,
      status: 'open',
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    }))
  };
}
```

## Migration Strategy

### Migration Commands

```bash
# Step 1: Backup existing configuration
opencode migrate --backup --from-version 0.4.0

# Step 2: Validate current setup
opencode config validate --from-version 0.4.0

# Step 3: Perform migration
opencode migrate --from-version 0.4.0 --to-version 0.5.0

# Step 4: Verify migration
opencode config validate --post-migration

# Step 5: Test functionality
opencode sync --dry-run
```

### Backward Compatibility Layer

```typescript
// packages/core/src/compatibility/LegacyAdapter.ts
export class LegacyAdapter {
  static adaptConfigV0_4(legacyConfig: any): UnifiedConfig {
    return {
      version: '0.5.0',
      github: {
        ...legacyConfig.github,
        apiUrl: legacyConfig.github?.apiUrl || 'https://api.github.com'
      },
      cody: {
        ...legacyConfig.cody,
        apiUrl: legacyConfig.cody?.apiUrl || 'https://api.cody.ai'
      },
      beads: {
        ...legacyConfig.beads,
        autoSync: legacyConfig.beads?.autoSync || false,
        syncInterval: legacyConfig.beads?.syncInterval || 300
      },
      sync: {
        ...legacyConfig.sync,
        preserveComments: legacyConfig.sync?.preserveComments ?? true,
        preserveLabels: legacyConfig.sync?.preserveLabels ?? true,
        syncMilestones: legacyConfig.sync?.syncMilestones ?? false
      }
    };
  }

  static migrateCommand(legacyCommand: string[]): string[] {
    // Convert old command structure to new unified structure
    const [cmd, ...args] = legacyCommand;
    
    switch (cmd) {
      case 'cody-beads':
        return ['opencode', 'sync', ...args];
      case 'opencode-config':
        return ['opencode', 'config', ...args];
      default:
        return ['opencode', cmd, ...args];
    }
  }
}
```

This comprehensive implementation plan provides a clear roadmap for achieving the v0.5.0 unified architecture while maintaining backward compatibility and ensuring robust testing coverage.